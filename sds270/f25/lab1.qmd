---
title: "Exercises: Names and Values"
subtitle: "SDS 270"
author: "PUT NAME HERE"
format: html
---

## Introduction

For these exercises, we will learn how to use the `lobstr` package to get information about objects in our environment.

**Goal:** By the end of these exercises, you will be able to determine whether an operation makes a copy, and compute the amount of memory each object occupies.

Fill in the code chunks and add written responses for each of the exercises. 

## Exercises

#### Measuring memory

First, load the `lobstr` package. This package contains many functions that will make it easier for us to figure out what R is doing under the hood. Also load the `tidyverse` package.

```{r}
library(lobstr)
library(tidyverse)
```


Your workspace should be empty.

::: {.callout-exercise}
###### Ex. 1:

Use `ls()` to list the objects in your workspace. If it is not empty, use the broom icon in the Environment tab in RStudio to empty it.

:::

```{r}
# Sample solution
ls()
```


Before we do anything, how much memory is being used by our R session?

```{r}
mem_used()
```

Recall that a byte is eight bits. A byte is a very small amount of information, typically used to store one character. A kilobyte is 1000 bytes, and a megabyte is 1000 kilobytes, etc. You should familiarize yourself briefly with the orders of magnitude of data.

Now suppose we add some things to our workspace. We can add objects, functions, or load packages. Does loading a package increase the memory used by our session?

::: {.callout-exercise}
##### Ex. 2:

Use the `library()` command to load the broom package. Then check the memory usage with `mem_used()`. Does loading a package increase the amount of memory used? By how much?

:::

```{r}
# Fill response here
```

::: {.callout-exercise}

##### Ex. 3:

What about loading a data set? Use the `data()` command to load the `iris` data set. Does that increase the memory usage? By how much?

:::

```{r}
# Fill response here
```

::: {.callout-exercise}

##### Ex. 4:

Use `obj_size()` to measure the amount of memory that `iris` takes up. Was the increase you observed previously equal to this amount?

:::

```{r}
# Fill response here
```

#### Making copies

As much fun as it is to make copies, each copy occupies memory. Generally, we want to minimize the amount of memory that our code needs to run.

Let’s store the amount of memory we are currently using.

```{r}
before <- mem_used()
```

Note the memory location of the `iris` data frame.

```{r}
ref(iris)
```

Note that we can bind a second name `my_iris` to the `iris` data frame, without making a copy.

```{r}
my_iris <- iris
ref(my_iris)
```

Now let’s change the data frame in a way that forces a copy to be made.

```{r}
my_iris <- my_iris |>
  mutate(sepal_area = Sepal.Length * Sepal.Width)
ref(my_iris)
```


Note that the memory locations of `my_iris` and `iris` are not the same anymore. However, the memory locations of the underlying vectors are the same!

::: {.callout-exercise}

##### Ex. 5:

Use `before` and `mem_used()` to calculate how much extra memory the copy of `my_iris` occupies.

:::

```{r}
# Fill response here
```

::: {.callout-exercise}

##### Ex. 6:

Is the difference you observed above equal to the size of the new column we created? Why or why not?

:::

```{r}
# Fill response here
```

Different representations of the same data may have different memory footprints. Suppose we change the iris data set into its long format.

```{r}
iris_long <- iris |>
  pivot_longer(-Species, names_to = "type", values_to = "measurement")
```

::: {.callout-exercise}

##### Ex. 7:

Does `iris_long` take up the same amount of memory as `iris`? Why or why not?

:::

```{r}
# Fill response here
```

We know that tibbles are like `data.frame`s. Do they take up the same amount of memory?

```{r}
before <- mem_used()
iris_tbl <- iris_long |>
  as_tibble()
mem_used() - before

class(iris_tbl)
```

Does converting a `data.frame` to a `tbl` force a copy?

```{r}
ref(iris_tbl)
ref(iris_long)
```

::: {.callout-exercise}

##### Ex. 8:

Discuss how using a tibble changes the memory footprint relative to using a `data.frame`.

:::

#### Tracing memory

Unfortunately, due to various complications and optimizations, it’s not always possible to reason ahead of time about whether R will make a copy of an object. Instead, we can use the `tracemem()` function to have R tell us whether it makes a copy and why.

First, note the memory location of iris.


```{r}
tracemem(iris)
```

We are now tracing this memory location. Some types of computations we make on `iris` do not require making a copy.

```{r}
iris |>
  pull(Petal.Length) |>
  mean()
```

However, if we modify iris using `mutate()`, a copy does get made.

```{r}
iris |>
  mutate(petal_area = Petal.Length * Petal.Width) |>
  as_tibble()
```

::: {.callout-exercise}

##### Ex. 9:

Experiment with different operations after invoking `tracemem()`. Can you get a feel for what operations induce copies?

```{r}
# Fill response here
```


:::

#### Garbage collection

Garbage collection is the process of reclaiming memory that is no longer being used. R does the automatically, but you can force the issue with `gc()`.

```{r}
gc()
```


#### Engagement (optional)

Take a minute to think about what questions you still have about names, values, and copies. Review what questions have been posted (in the #questions channel) recently by other students and either:

- respond (e.g., react, comment, clarify, or answer)
- post a new question

#### Turn in

Save this .qmd file and turn in on Moodle under "Exercises: Names and Values".
